---
author: 'Marcus Vinicius Richa'
title: 'GitLab Platform'
date: '2022-02-16'
subject: 'development-articles'
description: 'GitLab is a public available service that functions as remote repository to codes and also offers many other features related with development. It was founded by Dmitriy Zaporozhets and Valery Sizov in 2011, under MIT licence.'
---

# GitLab Platform

1. ##### Introduction  
2. ##### GitLab and GitLab Features
3. ##### GitLab Wiki 
4. ##### Basic GitLab Installations and Features
5. ##### Inatalled Linux Machine vs Kubernetes Container
6. ##### GitLab CI/CD
	6.1. Continuous Integration     
	6.2. Continuous Delivery       
	6.3. Continuous Deployment         
	6.4. Advantages of the GitLab CI/CD         
	6.5. Workflow of the GitLab CI/CD        
	6.6. Configuring GitLab Runners        
7. ##### Advanced GIT
	7.1. Understanting the GIT History Feature   
	7.2. Dangers and Best Practices    
	7.3. Branches are Pointers
8. #####
9. ##### Further Reading
10. ##### References


### Introduction

**Git** is a `version control system` used for:

- Handling the source code history of projects.
- Tracking changes made to files.
- Handling small and large projects with speed and efficiency.
- To collaborate with other developers on different projects.



### GitLab and GitLab Features

**GitLab** is a public available service, based on the Git tool that functions as remote repository to codes and also offers many other features related with development. 

It was founded by Dmitriy Zaporozhets and Valery Sizov in 2011, under MIT licence, and it received a stabe version in 2018.

`GitLab is great way to manage git repositories on centralized server. GitLab gives you complete control over your repositories or projects and allows you to decide whether they are public or private for free.`
[TutorialsPoint](https://www.tutorialspoint.com/gitlab/gitlab_introduction.htm)


- Hosts your (private) software projects for free.
- It is a plataform for managing Git repositories.
- It offers free public and private repositories, issue-tracking and wikis.
- It is a user friendly web interface layer on to of Git, which increases the speed of working with Git.
- It provides its own Continous Integration CCI) system for managing the projects and provides user interface along with other features of GitLab.


### GitLab Wiki

The Wiki Pages at GitLab is a feature that gives the developer the opportunity to keep documentation inside one project, but not as the same repository as the code itself.

It supports Markdown, RDoc, AciiDoc, and Org...


### Basic GitLab Installations and Features

There are two software distributions of GitLab:

1. **Community Edition (CE)**
2. **Enterprise Edition (EE)**


A typical install of GitLab is on GNU/Linux, but there is a growing number of deployments starting to use also the Kubernetes plataform. 

And some interesting features that it has are:

1. NGINX or Apache as default web server to proxy through **GitLab Workhorse** and into the **Puma** application server.
2. Server web pages and the GitLab API using **Puma** application server.
3. Uses Sidekiq as job queue which, in turn, uses Redis as a non-persistent database backend for job information, metadata, etc...
4. The GitLab application uses PostgreSQL for persistent database information. 

By default communication between Puma and Workhorse is via a Unix Domain Socket, but forward requests via TCP is also supported.


![gitlab-architecture-simplified](/images/articles/development/gitlab-architecture-simplified.png)


### Inatalled Linux Machine vs Kubernetes Container

- Official Linux packages can access files on the same file system with different services. Shared files are not an option for the application running on the Kubernetes platform.
- Official Linux packages by default have services that have access to the shared configuration and network. This is not the case for services running in Kubernetes, where services might be running in complete isolation, or only accessible through specific ports.

In other words, the shared state between services needs to be carefully considered when architecting new features and adding new components. Services that need to have access to the same files, need to be able to exchange information through the appropriate APIs. Whenever possible, this should not be done with files.

`Since components written with the API-first philosophy in mind are compatible with both methods, all new features and services must be written to consider Kubernetes compatibility first.`
[GitLab](https://docs.gitlab.com/ee/development/architecture.html)


### GitLab CI/CD

GitLab  CI/CD is a tool built into GitLab for sortware development through the continous methodologies:

- **Continous Integration (CI)**
- **Continous Delivery (CD)**
- **Continous Deployment (CD)**

So, the Continous Integration works by pushing small changes to your application's codebase hosted in a Git repository, and, to every push, run a pipeline of scripts to build, test, and validate the code changes before merging them into the main branch.

The Continous Delivery and Deployment consist of a step further CI, deploying you application to production at every push to the default branch of the repository.


#### Continous Integration

With this tool set, each change submitted to an application, even to development branches, is built and tested automatically and continously.


#### Continous Delivery

This feature of the tool is a step further in the process of continous development, because here not only the application updated is built and tested each time, but the application is also deployed continously. **However, with continous delivery, you have to trigger the deployments manually**.


#### Continous Deployment

This last feature is yet another step into continous integration that makes also the deployment phase automatic, making unnecessary the manual deployment of the application.


#### Advantages of the GitLab CI/CD

- It's easy to learn, use and scale.
- It's free and as an open source software it is added in both GitLab Community Edition and the proprietary GitLab Enterprise Edition.
- You can execute the jobs faster by setting up your own runner (it is an application that processes the builds) with all dependencies which are pre-installed.


#### Workflow of the GitLab CI/CD

The commom workflow set for the GitLab CI/CD looks like:

1. Some code is pushed to the remote GitLab repository.
2. The pipeline is triggered with tests.
	2.1. Build and Test
	2.2. Preview the changes in a `Review App`, the same as you would see on your `localhost`.
3. Review of the updates made
4. Approval of the updates made
5. **Merge the feature branch into the default branch**
	5.1. GitLab CI/CD deploys your changes automatically to a produduction environment.
6. If anything goes wrong, **it's possible to reset the changes made**.


![gitlab_workflow_example_extended_v12_3](/images/articles/development/gitlab_workflow_example_extended_v12_3.png)


#### Configuring GitLab Runners

A GitLab runner is a build instance which is used to run the jobs over multiple machines and send the results to GitLab and which can be place on separate users, servers, and local machine. You can register the runner as **shared** or **specific** after installing it.

1. **Shared runners**: these runners are usevul for jobs multiple projects which have similar requirements. Instead of using multiple runners for many projects, you can use a single or a small number of Runners to handle multiple projects which will be easy to maintain and update.
2. **Specific runners**: these runners are useful to deploy a certain project, if jobs have certain requirements or specific demand for the projects. Specific runners use FIFO (First In First Out) process for organizing the data with first-come first -served basis. 
	2.1. And a specific runner can be registered by using a project registration token.


Especial cases:

1. **Loked runner**: a specif runner can be locked from beign used by other projects at its settings.
2. **Protected runner**: a specif runner can be set as protected, so it only runs on pipelines that are triggered or on protected branches.
3. **Untagged jobs**: setting this property at the runners configuration interface will determine whether this runner can or cannot take jobs without tags.



### Advanced GIT

#### Understanting the GIT History Feature

The GIT History, or more appropriately speaking, the **history of the commits** from a repository is a hierarchy of related patches to a repository in a tree like fashion.


And the simplest way to see this tree of commits is to use the command **git log** and it's many attributes and flags, like:

1. **git log --patch or -p**: shows differences patched into each commit in the log.
2. **git log -2 (a number)**: limits the number o commits that are retrieved by the log.
3. **git log --stat**: brings the number of changed files with the number of insertions and deletions, and also a comparative graph for each file in relation to insertions and deletions.
4. **git log --pretty=<values>**:    
	1.1. oneline   
	1.2. short   
	1.3. full   
	1.4. fuller
5. **git log --pretty=format:<list of specifiers>**: see the list of specifiers below.


- **git log --pretty=format:<list of specifiesrs>**
```
Specifier 	Description of Output

%H 			Commit hash

%h			Abbreviated commit hash

%T			Tree hash

%t			Abbreviated tree hash

%P			Parent hashes

%p			Abbreviated parent hashes

%an			Author name (who wrote the work)

%ae			Author email

%ad			Author date (format respects the --date=option)

%ar			Author date, relative

%cn			Committer name (who last applied commit to the work)

%ce			Committer email

%cd			Committer date

%cr			Committer date, relative

%s			Subject
```


###### GIT commit --amend

The command **git commit --amend** is a convinient way to modify the last commit made, in the way you can **add** and combine a forgotten file with the last commit into a brand new single commit, or it is possible to change the message make to the commit:

```
$ git commit --amend -m "here, an updated commit message made"
```

Or, in the case of files fogotten:

```
# Edit hello.py and main.py
$ git add hello.py
$ git commit 
# Realize you forgot to add the changes from main.py 
$ git add main.py 
$ git commit --amend
``` 

But, attention, **do not amend public commits, because the current public commit that belong to others is going to be taken away from the history tree in favor of a brand new commit**.

`Remember to only amend commits that have not been pushed anywhere! The reason for this is that git commit --amend does not simply edit the last commit, it replaces that commit with an entirely new one. This means that you could potentially destroy a commit other developers are basing their work on. When rewriting history always make sure that you’re doing so in a safe manner, and that your coworkers are aware of what you’re doing.`


###### GIT rebase

The **git rebase** command is one of two git commands for integrating alterations from different branchs. The othe command is **git merge**. While **git merge** is a alteration in the registry forward, the **git rebase** allow to rewrite the registry, meaning that **git rebase** changes the history of the commits.


On the other hand, **the advantage** of using **git rebase** is to have a cleaner history, which could be extremele important to the work of analysing the history tree and reverting to definite point in the line. But once again, **do not rebase and change history from a public repository, because it will break and destroy old commits**.


Also interesting that by default **git rebase** does a automatic job, while **git rebase i** brings a interative session, that could be followed in this manner:

1. Create a repository and prepare some arbitrary changes.
2. Correct the mistakes made.

``` 
$ touch test{1..4}.md
$ git add test1.md && git commit -m 'Create first file'
$ git add test2.md && git commit -m 'Create send file'
$ git add test3.md && git commit -m 'Create third file and create fourth file'
``` 

See that there are 2 mistakes over there. The first mistake is the type "send" instead of "second", and the second mistake is that the fourth file was forgotten in the third commit.


The second mistake can be easily fixed with git **git --amend** while it is the last commit made. But to reach the second commit it could be done interatively with **git rebase -i**:

``` 
$ git log
$ git rebase -i HEAD~2
``` 


This will open the editor in the command line, but see that the 2 commits retrieved by the HEAD~2 (HEAD aka the current commit) property lists the commits in the opposite order from **git log**. This one is descending, and the **git rebase** is ascending:

```
edit eacf39d Create send file
pick 92ad0af Create third file and create fourth file
``` 

Above, the commit with the type comes first, so it was changed to be edited by changing **pick** for **edit**. And now that the **HEAD (aka the current commit)** is in the second commit, **amend** can be used and the change can be made either with the flag **-m** or with the command line editor. And when finished, hit continue:

```
$ git commit --amend
$ git rebase --continue
```


######  Squashing Commits

Squashing commits is a handy way of keeping the GIT history tidy, what could be even more important when the project leaves the development stage:

`Squashing makes it easier for others to understand the history of your project. What often happens when a feature is merged, is we end up with some visually complex logs of all the changes a feature branch had on a main branch. These commits are important while the feature is in development, but aren’t really necessary when looking through the entire history of your main branch.`


So, following the same example from above, it is possible to **squash** commit 2 into commit 1:

```
$ git rebase -i --root
``` 

Then it is necessary to **pich** and **squash** the commits according to one's need:

```
pick e30ff48 Create first file
squash 92aa6f3 Create second file
pick 05e5413 Create third file and create fourth file
``` 


So, up there, in the command line editor, the second commited was chosen to **squash** into its previous commit, without forgetting to rewrite the commit message for the squashed new commit. Then, log and see the results:

```
$ git log
Author: Marcus Vinicius Richa <marcus@protonmail.com>
Date:   Sat Aug 27 18:58:14 2022 -0300

    Create third file and create fourth file

commit d18797ec7ed81c446c56d710717d4776048e389d
Author: Marcus Vinicius Richa <marcus@protonmail.com>
Date:   Sat Aug 27 18:57:57 2022 -0300

    Create first and second file
``` 


###### GIT reset

The **git reset** command allows to undo some prior commit made, allowing some different direction. 


So, this time, keeping with the same example from above, it is possible to reset the the third commit and go another direction making 2 different commits, one for each separed file:

```
$ git reset HEAD^
$ git log
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	test3.md
	test4.md
``` 


Now, since the last commit was reset and undone, it can be rearranged:

```
$ git add test3.md && git commit -m 'Create third file'
$ git add test4.md && git commit -m 'Create fourth file'
$ git log
commit cb84da5c03bd5b4cc024a2277a6cfb3a85e0197d (HEAD -> main)
Author: Marcus Vinicius Richa <marcus@protonmail.com>
Date:   Sat Aug 27 19:50:09 2022 -0300

    Create fourth file

commit fb1ca3937bd4b65a2cb63c758aacb24d3d80f366
Author: Marcus Vinicius Richa <marcus@protonmail.com>
Date:   Sat Aug 27 19:49:59 2022 -0300

    Create third file

commit d18797ec7ed81c446c56d710717d4776048e389d
Author: Marcus Vinicius Richa <marcus@protonmail.com>
Date:   Sat Aug 27 18:57:57 2022 -0300

    Create first and second file
``` 


One important point to make is the fact that **git reset** can work with the flags:
1. **git reset --soft**
2. **git reset --hard**: this one is a destructive command, so be carreful specially while working with public repositories.


`The last part of reset we want to touch upon is git reset --hard. What this does is it performs all the steps of git reset, moving the HEAD and updating the index, but it also updates the working directory. This is important to note because it can be dangerous as it can potentially destroy data. A hard reset overwrites the files in the working directory to make it look exactly like the staging area of wherever HEAD ends up pointing to. Similarly to git commit --amend, a hard reset is a destructive command which overwrites history. This doesn’t mean you should completely avoid it if working with shared repositories on a team with other developers. You should, however, make sure you know exactly why you’re using it, and that your coworkers are also aware of how and why you’re using it.`


###### GIT revert

Note that the command **git revert** works for undo registries in the history of commits, but different from other commands like **git checkout** and **git reset**, which move the pointer of reference from HEAD, the **git revert** gets some speciffic commit, but keeps the HEAD at the same place.


What this means is that if **git reset** is used some point back in the history, the HEAD changes to it and everything ahead has to be reconfirmed until it reaches the last point in the log history.


On the other hand, **git revert** is a safer option to undo operations, according to [Atlassian - Git revert](https://www.atlassian.com/br/git/tutorials/undoing-changes/git-revert).


#### Dangers and Best Practices Branches are Pointers

Remember that **git amend**, **git rebase**, **git reset**, **git push --force** are all destructive commands, so it is better to work following **best practices**:
1. If working on a team project, make sure rewriting history is safe to do and others know you're doing it.
2. Ideally, stick to using the same commands only on brances that your're working with by yourself.
3. Using the **-f** flag to force something should scare you, and you better have a really good reason for doing it.
4. Don't push after every single commit, changing published history should be avoided when possible.
5. Regarding to the speciffic commands spoken of:   
	1. For **git amend** never amend commits that have been pushed to remote repositories.   
	2. For **gir rebase** never rebase a repository that others may work off of.   
	3. For **git reset** never reset commits that have been pushed to remote repositories.   
	4.  For **git push --force** only use it when appropriate, use it with caution, and preferably default to using **git push --force-with-lease**.



#### Branches are Pointers














### Further Reading

[GitLab architecture overview - GitLab](https://docs.gitlab.com/ee/development/architecture.html)

[Get started with GitLab CI/CD - GitLab](https://docs.gitlab.com/ee/ci/quick_start/)

[Learn GitLab in 3 Hours | GitLab Complete Tutorial For Beginners - LambdaTest](https://www.youtube.com/watch?v=8aV5AxJrHDg)

### References


[GitLab - TutorialsPoint](https://www.tutorialspoint.com/gitlab/gitlab_introduction.htm)



